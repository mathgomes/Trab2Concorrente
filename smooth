#include <iostream>
#include <vector>

#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/features2d/features2d.hpp"

using namespace std;
using namespace cv;

/// Global Variables
#define KERNEL_LENGTH 25

int DELAY_CAPTION = 1500;
int DELAY_BLUR = 100;
char window_name[] = "Smoothing Demo";

Mat src, dst[3], finImg;

Mat mediaBlur(Mat img);
int display_finImg(int delay);

int main( void )
{
  int i;
  /// Load the source image
  src = imread( "../data/baboon.jpg", 1 );

  split(src,dst);

  for(i=0;i<3;++i){
    dst[i] = mediaBlur(dst[i]);
  }
  
  vector<Mat> rgb ;
  rgb.push_back(dst[0]); //blue
  rgb.push_back(dst[1]); //green
  rgb.push_back(dst[2]); //red

	
  /// Merge the three channels
  merge(rgb, finImg);

  if( display_finImg( DELAY_CAPTION) != 0 ) { return 0; }

  waitKey(0);
 	
  return 0;
}



Mat mediaBlur(Mat channel){
  int i, j, l, c, tamlin = channel.rows, tamcol = channel.cols, sum;
  double media;
  for(i = 0; i < tamlin; ++i){
    for(j = 0; j < tamcol; ++j){
	sum=0;
	for(l=(i-2); l < (i+2) ;++l){
          for(c=(j-2); c < (j+2) ;++c){
            if(l>=0 && c>=0 && l < tamlin && c < tamcol){  
              sum += channel.at<uchar>(l,c);
	    }
	  }
	}
        media = sum/KERNEL_LENGTH;
	channel.at<uchar>(i,j) = media;
    }
  }  
  return channel;
}


int display_finImg(int delay){
  imshow( window_name, finImg);
  int c = waitKey ( delay );
  if( c >= 0 ) { return -1; }	
  return 0;
}

/*
Mat mediaBlur(Mat channel){
  int i, j, k, s=0, sum=0, indcol, indlin=1, tamcol, tamlin= KERNEL_LENGTH;
  double media;

  printf("\n channel[row][col]: %d %d \n", channel.rows, channel.cols);
 
  while(s<2){
 	  k=0;
	  indcol=1;
	  tamcol = KERNEL_LENGTH;

	  while(k<2){

	    for(i = (KERNEL_LENGTH * (indlin-1)); i < tamlin; ++i){
	      for(j = (KERNEL_LENGTH * (indcol-1)); j < tamcol; ++j){
		 sum += channel.at<uchar>(i,j);
	      }
	    }

	    printf("sum:%d \n", sum);
	    media = sum/((tamcol - (KERNEL_LENGTH*(indcol-1))) * (tamlin - (KERNEL_LENGTH*(indlin-1))));
	    printf("media: %0.2f \n", media);
	    channel.at<uchar>( ((KERNEL_LENGTH * (indlin-1)) + (tamlin - (KERNEL_LENGTH * (indlin-1)))/2) , ((KERNEL_LENGTH * (indcol-1)) + (tamcol - (KERNEL_LENGTH * (indcol-1)))/2)) = media;
	    sum=0;
	    indcol+=1;

	    if(KERNEL_LENGTH * (indcol) >= channel.cols){
	      tamcol = channel.cols;
	      k+=1;
	    }else{
	      tamcol = KERNEL_LENGTH * (indcol);
	    }

	  }

	  indlin+=1;
	  	
	  if(KERNEL_LENGTH * (indlin) >= channel.rows){
	    tamlin = channel.rows;
	    s+=1;
	  }else{
	    tamlin = KERNEL_LENGTH * (indlin);
	  }
  }

  return channel;
}*/
